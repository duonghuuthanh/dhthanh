{
    "subject": "Các ghi chú nổi bật",
    "type": "note",
    "data": [{
        "title": "Con trỏ trong C++",
        "content": "Miền giá trị của biến con trỏ là địa chỉ ô nhớ."
    }, {
        "title": "Danh sách đặc và danh sách liên kết",
        "content": "<h5>Danh sách đặc</h5><ul><li>Kích thước danh sách cố định.</li><li>Các ô nhớ của các phần tử tổ chức liên tiếp trong bộ nhớ. -> Thao tác tìm kiếm nhanh, chèn và xoá chậm.</li></ul><h5>Danh sách liên kết</h5><ul><li>Kích thước danh sách không giới hạn.</li><li>Các ô nhớ của các phần tử tổ chức rời rạc trong bộ nhớ. -> thao tác chèn, xoá nhanh, tìm kiếm chậm.</li></ul>"
    }, {
        "title": "Ưu điểm chính của lập trình hướng đối tượng",
        "content": "<ul><li>OOP cho phép <strong>che giấu dữ liệu</strong>, hạn chế tối đa truy cập từ bên ngoài.</li><li>OOP cho phép <strong>tái sử dụng</strong> mã nguồn hiệu quả, tiết kiệm thời gian của lập trình viên, cũng như giúp cho việc mở rộng chương trình, bảo trì trở nên dễ dàng hơn.</li></ul>"
    }, {
        "title": "Các đặc điểm của OOP",
        "content": "<ul><li>Trừu tượng hoá (abstraction)</li><li>Đóng gói (Encapsulation)</li><li>Kế thừa (Inheritance)</li><li>Đa hình (Polymorphism)</li></ul>"
    }, {
        "title": "DRY (Don’t Repeat Yourself)",
        "content": "Mã nguồn lặp dẫn đến dễ phát sinh lỗi, khó khăn trong việc bảo trì phần mềm, thay đổi chương trình."
    }, {
        "title": "KISS (Keep It Simple Stupid!)",
        "content": "Sự phức tạp không cần thiết nên bỏ qua."
    }, {
        "title": "YAGNI (You Aren’t Gonna Need It)",
        "content": "Chỉ thực hiện các chức năng thật sự cần thiết."
    }, {
        "title": "Loose Coupling & High Conhension",
        "content": "<ul><li>Loose Coupling: giữa các component càng ít phụ thuộc nhau càng tốt.Ngược lại gọi là tight coupling, điều này sẽ dẫn đến khó khăn trong việc tái sử dụng component, cũng như chỉnh sửa hay bảo trì hệ thống.</li><li>High Cohesion: các thành phần trong một component càng phụ thuộc nhau càng tốt.</li></ul>"
    }, {
        "title": "3 nguyên tắc vàng thiết kế giao diện (Mandel [Man97])",
        "content": "<ul><li>Người dùng được phép linh hoạt tương tác giao diện (Place the user in control).</li><li>Hạn chế bắt người dùng nhớ quá nhiều thông tin khi tương tác giao diện (Reduce the user’s memory load).</li><li>Thiết kế giao diện nhất quán (Make the interface consistent).</li></ul>"
    }, {
        "title": "Tính chất ACID của giao tác",
        "content": "<ul><li title='tức là một giao tác thành công nếu tất cả các thao tác của nó thành công, ngược lại tồn tại một thao tác thất bại thì toàn bộ giao tác thất bại'>A (Atomicity): giao tác là một đơn vị xử lý nguyên tố, không thể chia nhỏ.</li><li>C (Consistency): một giao tác phải chuyển cơ sở dữ liệu từ trạng thái nhất quán này sang trạng thái nhất quán khác.</li><li title='tức là giao tác này không thể thấy được tác động của giao tác khác nếu nó chưa hoàn thành'>I (Isolation): một giao tác phải được cô lập với các giao tác khác.</li><li>D (Durability): một giao tác khi hoàn tất, kết quả của giao tác sẽ tác động bền vững và không thể xoá đi dưới cơ sở dữ liệu từ những vấn đề của hệ thống</li></ul>"
    }, {
        "title": "Các nguyên tắc kiểm thử phần mềm",
        "content": "<ul><li>Kiểm thử vét cạn là bất khả thi (exhaustive testing is impossible).</li><li>Kiểm thử sớm (early testing): quá trình kiểm thử nên bắt đầu càng sớm càng tốt trong quy trình phát triển phần mềm vì chi phí phải trả sẽ càng tăng nếu lỗi được tìm thấy càng trễ trong quy trình phát triển phần mềm </li><li>Gom cụm lỗi (defect clustering): lỗi thường tập trung ở một vài module, tính năng của hệ thống.</li><li>Nguyên lý thuốc trừ sâu (pesticide paradox): một bộ test case nếu được thực hiện lặp đi lặp lại sẽ khó phát hiện bug mới. Test case cần được kiểm tra, đánh giá, viết lại và thêm mới thường xuyên sẽ giúp phát hiện nhiều bug hơn.</li><li>Kiểm thử phụ thuộc ngữ cảnh (testing is context dependent): mỗi lĩnh vực có yêu cầu, chức năng, ràng buộc, rủi ro và mục đích kiểm thử khác nhau.</li><li>Sự vắng mặt của lỗi là ảo tưởng (absence–of–errors fallacy)</li></ul>"
    }]
}